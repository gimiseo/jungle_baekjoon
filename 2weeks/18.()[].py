# 일단 드는 아이디어
#(로 시작했다? 그럼 절대 반대를 만나면 안된다... (] 라던가 [)라던가 반면 그것만 아니면 전부 가능
#올바르지 않으면 0 출력. 인자 값은 문자열로 받는다.
#스택으로 (나 [를 받아준다. top을 항상 유지하다가 올바른 닫기를 만나면 풀어준다.
# 올바른 닫기가 무엇인지 계속 인지시킨다. 예를들어 ([((((([ 일경우
# ]를 만나면 pop하면서 일단 스택으로 받아가자

# ‘()’ 인 괄호열의 값은 2이다.
# ‘[]’ 인 괄호열의 값은 3이다.
# ‘(X)’ 의 괄호값은 2×값(X) 으로 계산된다.
# ‘[X]’ 의 괄호값은 3×값(X) 으로 계산된다.
# 올바른 괄호열 X와 Y가 결합된 XY의 괄호값은 값(XY)= 값(X)+값(Y) 로 계산된다.
# 예를 들어 ‘(()[[]])([])’ 의 괄호값을 구해보자. ‘()[[]]’ 의 괄호값이 2 + 3×3=11 이므로 
# ‘(()[[]])’의 괄호값은 2×11=22 이다. 그리고 ‘([])’의 값은 2×3=6 이므로 
# 전체 괄호열의 값은 22 + 6 = 28 이다.
# 여러분이 풀어야 할 문제는 주어진 괄호열을 읽고 그 괄호값을 앞에서 정의한대로 계산하여 출력하는 것이다.

# 덧셈 현황도 기억을 해놔야하지않을까?
# 번쩍이는 아이디어. )나 ] 를 만날때 최종 계산을 해본다...?
#그럼 스택에 점수를 어떻게 쌓아..?
#아 오키
# result를 만들고 쌓아간다.
# 예를 들어, (()[[]])([])이라고 하면, result = 0 
#(만난다. 스택에 쌓는다 (를 또 만났다 스택에 쌓는다. )를 만난다. 
#(를 만날때마다 [0]을 append 해준다.
#)를 만났다. 계산을 한다. 
# 이중스택으로 해볼까 고민중
#)를 만나면 이중스택 상단에서 쌓여가던 계산들이 상단에 쌓여감
#가령 (()[[]])([])이라고 한다면 (를 스타트로 stack[0] 선언
#또(를 만나면서 stack[1] 선언
# )를 만나면서 stack[-1]확인, 쌓여진 값 확인 후 )이면 2곱
# 쌓여진게 없으므로 2, 그 값을 다음 top에 추가
# stack[0]에는 2 추가
# 그 후 쌓여간다면 다 더하고 곱, 쌓아가기 곱 쌓아가기
# 필요한 기술 스텍, 일단 이중 스택이 되는지 확인
# 이중 스택이라고 한다면 쌓여가는 와중에 덧셈현황을 기억해보는것이다.
# 일단 해보고 이렇게 까지 할 필요가 없다면 고쳐나가는 것으로

# test_stack = []

# test_stack.append([])
# test_stack.append([])
# test_stack[-1].append(2)
# print(test_stack)
# test_stack.pop()
# test_stack[-1].append(2)
# test_stack[-1].append(9)

# print(test_stack)

#이게 되네.
#그러면 방향성이 잡혔다. (나 [를 만나면 스택 생성, 아 지렸다. 맨 첫단에 2로 곱할건지 3으로 곱할건지 정할까?
#그러면 (나 [를 만나면 [(]나 [[]을 appeand 한다. 
# 그러면 어차피 ) ] 들어오면 판단해야하니까 그때 2를 곱할지 3을 곱할지 
# 직관적으로 하기로 했으니까 내가 잘 핸들링하면 될듯

#좋아 그럼 영광의 첫 코드는 뭘 적을까?

str = input()

stack = []
real_total = 0
# 문자열을 다 스캔해야겠죠?
for i in range(len(str)):
    if str[i] == "(" or str[i] == "[":
        stack.append([ord(str[i]) // 10])
    else:
        if stack and stack[-1][0] == (ord(str[i]) // 10):
            total = sum(stack[-1][1:])
            if total == 0:
                total = 1
            total = total * (stack[-1][0] ** 0.5)
            stack.pop()
            if stack:
                stack[-1].append(total)
            else:
                real_total += int(total)
        else:
            print(0)
            exit()
if stack:
    print(0)
else:
    print(real_total)
# print(ord('(')) # 40
# print(ord('[')) # 91